{"ast":null,"code":"var crypto = require('crypto'),\n    sha1 = require('./sha1'),\n    http = require('http'),\n    https = require('https'),\n    URL = require('url'),\n    querystring = require('querystring'),\n    OAuthUtils = require('./_utils');\n\nexports.OAuth = function (requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {\n  this._isEcho = false;\n  this._requestUrl = requestUrl;\n  this._accessUrl = accessUrl;\n  this._consumerKey = consumerKey;\n  this._consumerSecret = this._encodeData(consumerSecret);\n\n  if (signatureMethod == \"RSA-SHA1\") {\n    this._privateKey = consumerSecret;\n  }\n\n  this._version = version;\n\n  if (authorize_callback === undefined) {\n    this._authorize_callback = \"oob\";\n  } else {\n    this._authorize_callback = authorize_callback;\n  }\n\n  if (signatureMethod != \"PLAINTEXT\" && signatureMethod != \"HMAC-SHA1\" && signatureMethod != \"RSA-SHA1\") throw new Error(\"Un-supported signature method: \" + signatureMethod);\n  this._signatureMethod = signatureMethod;\n  this._nonceSize = nonceSize || 32;\n  this._headers = customHeaders || {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"User-Agent\": \"Node authentication\"\n  };\n  this._clientOptions = this._defaultClientOptions = {\n    \"requestTokenHttpMethod\": \"POST\",\n    \"accessTokenHttpMethod\": \"POST\",\n    \"followRedirects\": true\n  };\n  this._oauthParameterSeperator = \",\";\n};\n\nexports.OAuthEcho = function (realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {\n  this._isEcho = true;\n  this._realm = realm;\n  this._verifyCredentials = verify_credentials;\n  this._consumerKey = consumerKey;\n  this._consumerSecret = this._encodeData(consumerSecret);\n\n  if (signatureMethod == \"RSA-SHA1\") {\n    this._privateKey = consumerSecret;\n  }\n\n  this._version = version;\n  if (signatureMethod != \"PLAINTEXT\" && signatureMethod != \"HMAC-SHA1\" && signatureMethod != \"RSA-SHA1\") throw new Error(\"Un-supported signature method: \" + signatureMethod);\n  this._signatureMethod = signatureMethod;\n  this._nonceSize = nonceSize || 32;\n  this._headers = customHeaders || {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"User-Agent\": \"Node authentication\"\n  };\n  this._oauthParameterSeperator = \",\";\n};\n\nexports.OAuthEcho.prototype = exports.OAuth.prototype;\n\nexports.OAuth.prototype._getTimestamp = function () {\n  return Math.floor(new Date().getTime() / 1000);\n};\n\nexports.OAuth.prototype._encodeData = function (toEncode) {\n  if (toEncode == null || toEncode == \"\") return \"\";else {\n    var result = encodeURIComponent(toEncode); // Fix the mismatch between OAuth's  RFC3986's and Javascript's beliefs in what is right and wrong ;)\n\n    return result.replace(/\\!/g, \"%21\").replace(/\\'/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n  }\n};\n\nexports.OAuth.prototype._decodeData = function (toDecode) {\n  if (toDecode != null) {\n    toDecode = toDecode.replace(/\\+/g, \" \");\n  }\n\n  return decodeURIComponent(toDecode);\n};\n\nexports.OAuth.prototype._getSignature = function (method, url, parameters, tokenSecret) {\n  var signatureBase = this._createSignatureBase(method, url, parameters);\n\n  return this._createSignature(signatureBase, tokenSecret);\n};\n\nexports.OAuth.prototype._normalizeUrl = function (url) {\n  var parsedUrl = URL.parse(url, true);\n  var port = \"\";\n\n  if (parsedUrl.port) {\n    if (parsedUrl.protocol == \"http:\" && parsedUrl.port != \"80\" || parsedUrl.protocol == \"https:\" && parsedUrl.port != \"443\") {\n      port = \":\" + parsedUrl.port;\n    }\n  }\n\n  if (!parsedUrl.pathname || parsedUrl.pathname == \"\") parsedUrl.pathname = \"/\";\n  return parsedUrl.protocol + \"//\" + parsedUrl.hostname + port + parsedUrl.pathname;\n}; // Is the parameter considered an OAuth parameter\n\n\nexports.OAuth.prototype._isParameterNameAnOAuthParameter = function (parameter) {\n  var m = parameter.match('^oauth_');\n\n  if (m && m[0] === \"oauth_\") {\n    return true;\n  } else {\n    return false;\n  }\n}; // build the OAuth request authorization header\n\n\nexports.OAuth.prototype._buildAuthorizationHeaders = function (orderedParameters) {\n  var authHeader = \"OAuth \";\n\n  if (this._isEcho) {\n    authHeader += 'realm=\"' + this._realm + '\",';\n  }\n\n  for (var i = 0; i < orderedParameters.length; i++) {\n    // Whilst the all the parameters should be included within the signature, only the oauth_ arguments\n    // should appear within the authorization header.\n    if (this._isParameterNameAnOAuthParameter(orderedParameters[i][0])) {\n      authHeader += \"\" + this._encodeData(orderedParameters[i][0]) + \"=\\\"\" + this._encodeData(orderedParameters[i][1]) + \"\\\"\" + this._oauthParameterSeperator;\n    }\n  }\n\n  authHeader = authHeader.substring(0, authHeader.length - this._oauthParameterSeperator.length);\n  return authHeader;\n}; // Takes an object literal that represents the arguments, and returns an array\n// of argument/value pairs.\n\n\nexports.OAuth.prototype._makeArrayOfArgumentsHash = function (argumentsHash) {\n  var argument_pairs = [];\n\n  for (var key in argumentsHash) {\n    if (argumentsHash.hasOwnProperty(key)) {\n      var value = argumentsHash[key];\n\n      if (Array.isArray(value)) {\n        for (var i = 0; i < value.length; i++) {\n          argument_pairs[argument_pairs.length] = [key, value[i]];\n        }\n      } else {\n        argument_pairs[argument_pairs.length] = [key, value];\n      }\n    }\n  }\n\n  return argument_pairs;\n}; // Sorts the encoded key value pairs by encoded name, then encoded value\n\n\nexports.OAuth.prototype._sortRequestParams = function (argument_pairs) {\n  // Sort by name, then value.\n  argument_pairs.sort(function (a, b) {\n    if (a[0] == b[0]) {\n      return a[1] < b[1] ? -1 : 1;\n    } else return a[0] < b[0] ? -1 : 1;\n  });\n  return argument_pairs;\n};\n\nexports.OAuth.prototype._normaliseRequestParams = function (args) {\n  var argument_pairs = this._makeArrayOfArgumentsHash(args); // First encode them #3.4.1.3.2 .1\n\n\n  for (var i = 0; i < argument_pairs.length; i++) {\n    argument_pairs[i][0] = this._encodeData(argument_pairs[i][0]);\n    argument_pairs[i][1] = this._encodeData(argument_pairs[i][1]);\n  } // Then sort them #3.4.1.3.2 .2\n\n\n  argument_pairs = this._sortRequestParams(argument_pairs); // Then concatenate together #3.4.1.3.2 .3 & .4\n\n  var args = \"\";\n\n  for (var i = 0; i < argument_pairs.length; i++) {\n    args += argument_pairs[i][0];\n    args += \"=\";\n    args += argument_pairs[i][1];\n    if (i < argument_pairs.length - 1) args += \"&\";\n  }\n\n  return args;\n};\n\nexports.OAuth.prototype._createSignatureBase = function (method, url, parameters) {\n  url = this._encodeData(this._normalizeUrl(url));\n  parameters = this._encodeData(parameters);\n  return method.toUpperCase() + \"&\" + url + \"&\" + parameters;\n};\n\nexports.OAuth.prototype._createSignature = function (signatureBase, tokenSecret) {\n  if (tokenSecret === undefined) var tokenSecret = \"\";else tokenSecret = this._encodeData(tokenSecret); // consumerSecret is already encoded\n\n  var key = this._consumerSecret + \"&\" + tokenSecret;\n  var hash = \"\";\n\n  if (this._signatureMethod == \"PLAINTEXT\") {\n    hash = key;\n  } else if (this._signatureMethod == \"RSA-SHA1\") {\n    key = this._privateKey || \"\";\n    hash = crypto.createSign(\"RSA-SHA1\").update(signatureBase).sign(key, 'base64');\n  } else {\n    if (crypto.Hmac) {\n      hash = crypto.createHmac(\"sha1\", key).update(signatureBase).digest(\"base64\");\n    } else {\n      hash = sha1.HMACSHA1(key, signatureBase);\n    }\n  }\n\n  return hash;\n};\n\nexports.OAuth.prototype.NONCE_CHARS = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nexports.OAuth.prototype._getNonce = function (nonceSize) {\n  var result = [];\n  var chars = this.NONCE_CHARS;\n  var char_pos;\n  var nonce_chars_length = chars.length;\n\n  for (var i = 0; i < nonceSize; i++) {\n    char_pos = Math.floor(Math.random() * nonce_chars_length);\n    result[i] = chars[char_pos];\n  }\n\n  return result.join('');\n};\n\nexports.OAuth.prototype._createClient = function (port, hostname, method, path, headers, sslEnabled) {\n  var options = {\n    host: hostname,\n    port: port,\n    path: path,\n    method: method,\n    headers: headers\n  };\n  var httpModel;\n\n  if (sslEnabled) {\n    httpModel = https;\n  } else {\n    httpModel = http;\n  }\n\n  return httpModel.request(options);\n};\n\nexports.OAuth.prototype._prepareParameters = function (oauth_token, oauth_token_secret, method, url, extra_params) {\n  var oauthParameters = {\n    \"oauth_timestamp\": this._getTimestamp(),\n    \"oauth_nonce\": this._getNonce(this._nonceSize),\n    \"oauth_version\": this._version,\n    \"oauth_signature_method\": this._signatureMethod,\n    \"oauth_consumer_key\": this._consumerKey\n  };\n\n  if (oauth_token) {\n    oauthParameters[\"oauth_token\"] = oauth_token;\n  }\n\n  var sig;\n\n  if (this._isEcho) {\n    sig = this._getSignature(\"GET\", this._verifyCredentials, this._normaliseRequestParams(oauthParameters), oauth_token_secret);\n  } else {\n    if (extra_params) {\n      for (var key in extra_params) {\n        if (extra_params.hasOwnProperty(key)) oauthParameters[key] = extra_params[key];\n      }\n    }\n\n    var parsedUrl = URL.parse(url, false);\n\n    if (parsedUrl.query) {\n      var key2;\n      var extraParameters = querystring.parse(parsedUrl.query);\n\n      for (var key in extraParameters) {\n        var value = extraParameters[key];\n\n        if (typeof value == \"object\") {\n          // TODO: This probably should be recursive\n          for (key2 in value) {\n            oauthParameters[key + \"[\" + key2 + \"]\"] = value[key2];\n          }\n        } else {\n          oauthParameters[key] = value;\n        }\n      }\n    }\n\n    sig = this._getSignature(method, url, this._normaliseRequestParams(oauthParameters), oauth_token_secret);\n  }\n\n  var orderedParameters = this._sortRequestParams(this._makeArrayOfArgumentsHash(oauthParameters));\n\n  orderedParameters[orderedParameters.length] = [\"oauth_signature\", sig];\n  return orderedParameters;\n};\n\nexports.OAuth.prototype._performSecureRequest = function (oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback) {\n  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);\n\n  if (!post_content_type) {\n    post_content_type = \"application/x-www-form-urlencoded\";\n  }\n\n  var parsedUrl = URL.parse(url, false);\n  if (parsedUrl.protocol == \"http:\" && !parsedUrl.port) parsedUrl.port = 80;\n  if (parsedUrl.protocol == \"https:\" && !parsedUrl.port) parsedUrl.port = 443;\n  var headers = {};\n\n  var authorization = this._buildAuthorizationHeaders(orderedParameters);\n\n  if (this._isEcho) {\n    headers[\"X-Verify-Credentials-Authorization\"] = authorization;\n  } else {\n    headers[\"Authorization\"] = authorization;\n  }\n\n  headers[\"Host\"] = parsedUrl.host;\n\n  for (var key in this._headers) {\n    if (this._headers.hasOwnProperty(key)) {\n      headers[key] = this._headers[key];\n    }\n  } // Filter out any passed extra_params that are really to do with OAuth\n\n\n  for (var key in extra_params) {\n    if (this._isParameterNameAnOAuthParameter(key)) {\n      delete extra_params[key];\n    }\n  }\n\n  if ((method == \"POST\" || method == \"PUT\") && post_body == null && extra_params != null) {\n    // Fix the mismatch between the output of querystring.stringify() and this._encodeData()\n    post_body = querystring.stringify(extra_params).replace(/\\!/g, \"%21\").replace(/\\'/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n  }\n\n  if (post_body) {\n    if (Buffer.isBuffer(post_body)) {\n      headers[\"Content-length\"] = post_body.length;\n    } else {\n      headers[\"Content-length\"] = Buffer.byteLength(post_body);\n    }\n  } else {\n    headers[\"Content-length\"] = 0;\n  }\n\n  headers[\"Content-Type\"] = post_content_type;\n  var path;\n  if (!parsedUrl.pathname || parsedUrl.pathname == \"\") parsedUrl.pathname = \"/\";\n  if (parsedUrl.query) path = parsedUrl.pathname + \"?\" + parsedUrl.query;else path = parsedUrl.pathname;\n  var request;\n\n  if (parsedUrl.protocol == \"https:\") {\n    request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);\n  } else {\n    request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);\n  }\n\n  var clientOptions = this._clientOptions;\n\n  if (callback) {\n    var data = \"\";\n    var self = this; // Some hosts *cough* google appear to close the connection early / send no content-length header\n    // allow this behaviour.\n\n    var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(parsedUrl.hostname);\n    var callbackCalled = false;\n\n    var passBackControl = function (response) {\n      if (!callbackCalled) {\n        callbackCalled = true;\n\n        if (response.statusCode >= 200 && response.statusCode <= 299) {\n          callback(null, data, response);\n        } else {\n          // Follow 301 or 302 redirects with Location HTTP header\n          if ((response.statusCode == 301 || response.statusCode == 302) && clientOptions.followRedirects && response.headers && response.headers.location) {\n            self._performSecureRequest(oauth_token, oauth_token_secret, method, response.headers.location, extra_params, post_body, post_content_type, callback);\n          } else {\n            callback({\n              statusCode: response.statusCode,\n              data: data\n            }, data, response);\n          }\n        }\n      }\n    };\n\n    request.on('response', function (response) {\n      response.setEncoding('utf8');\n      response.on('data', function (chunk) {\n        data += chunk;\n      });\n      response.on('end', function () {\n        passBackControl(response);\n      });\n      response.on('close', function () {\n        if (allowEarlyClose) {\n          passBackControl(response);\n        }\n      });\n    });\n    request.on(\"error\", function (err) {\n      if (!callbackCalled) {\n        callbackCalled = true;\n        callback(err);\n      }\n    });\n\n    if ((method == \"POST\" || method == \"PUT\") && post_body != null && post_body != \"\") {\n      request.write(post_body);\n    }\n\n    request.end();\n  } else {\n    if ((method == \"POST\" || method == \"PUT\") && post_body != null && post_body != \"\") {\n      request.write(post_body);\n    }\n\n    return request;\n  }\n\n  return;\n};\n\nexports.OAuth.prototype.setClientOptions = function (options) {\n  var key,\n      mergedOptions = {},\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (key in this._defaultClientOptions) {\n    if (!hasOwnProperty.call(options, key)) {\n      mergedOptions[key] = this._defaultClientOptions[key];\n    } else {\n      mergedOptions[key] = options[key];\n    }\n  }\n\n  this._clientOptions = mergedOptions;\n};\n\nexports.OAuth.prototype.getOAuthAccessToken = function (oauth_token, oauth_token_secret, oauth_verifier, callback) {\n  var extraParams = {};\n\n  if (typeof oauth_verifier == \"function\") {\n    callback = oauth_verifier;\n  } else {\n    extraParams.oauth_verifier = oauth_verifier;\n  }\n\n  this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function (error, data, response) {\n    if (error) callback(error);else {\n      var results = querystring.parse(data);\n      var oauth_access_token = results[\"oauth_token\"];\n      delete results[\"oauth_token\"];\n      var oauth_access_token_secret = results[\"oauth_token_secret\"];\n      delete results[\"oauth_token_secret\"];\n      callback(null, oauth_access_token, oauth_access_token_secret, results);\n    }\n  });\n}; // Deprecated\n\n\nexports.OAuth.prototype.getProtectedResource = function (url, method, oauth_token, oauth_token_secret, callback) {\n  this._performSecureRequest(oauth_token, oauth_token_secret, method, url, null, \"\", null, callback);\n};\n\nexports.OAuth.prototype.delete = function (url, oauth_token, oauth_token_secret, callback) {\n  return this._performSecureRequest(oauth_token, oauth_token_secret, \"DELETE\", url, null, \"\", null, callback);\n};\n\nexports.OAuth.prototype.get = function (url, oauth_token, oauth_token_secret, callback) {\n  return this._performSecureRequest(oauth_token, oauth_token_secret, \"GET\", url, null, \"\", null, callback);\n};\n\nexports.OAuth.prototype._putOrPost = function (method, url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {\n  var extra_params = null;\n\n  if (typeof post_content_type == \"function\") {\n    callback = post_content_type;\n    post_content_type = null;\n  }\n\n  if (typeof post_body != \"string\" && !Buffer.isBuffer(post_body)) {\n    post_content_type = \"application/x-www-form-urlencoded\";\n    extra_params = post_body;\n    post_body = null;\n  }\n\n  return this._performSecureRequest(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback);\n};\n\nexports.OAuth.prototype.put = function (url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {\n  return this._putOrPost(\"PUT\", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);\n};\n\nexports.OAuth.prototype.post = function (url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {\n  return this._putOrPost(\"POST\", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);\n};\n/**\n * Gets a request token from the OAuth provider and passes that information back\n * to the calling code.\n *\n * The callback should expect a function of the following form:\n *\n * function(err, token, token_secret, parsedQueryString) {}\n *\n * This method has optional parameters so can be called in the following 2 ways:\n *\n * 1) Primary use case: Does a basic request with no extra parameters\n *  getOAuthRequestToken( callbackFunction )\n *\n * 2) As above but allows for provision of extra parameters to be sent as part of the query to the server.\n *  getOAuthRequestToken( extraParams, callbackFunction )\n *\n * N.B. This method will HTTP POST verbs by default, if you wish to override this behaviour you will\n * need to provide a requestTokenHttpMethod option when creating the client.\n *\n **/\n\n\nexports.OAuth.prototype.getOAuthRequestToken = function (extraParams, callback) {\n  if (typeof extraParams == \"function\") {\n    callback = extraParams;\n    extraParams = {};\n  } // Callbacks are 1.0A related\n\n\n  if (this._authorize_callback) {\n    extraParams[\"oauth_callback\"] = this._authorize_callback;\n  }\n\n  this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, extraParams, null, null, function (error, data, response) {\n    if (error) callback(error);else {\n      var results = querystring.parse(data);\n      var oauth_token = results[\"oauth_token\"];\n      var oauth_token_secret = results[\"oauth_token_secret\"];\n      delete results[\"oauth_token\"];\n      delete results[\"oauth_token_secret\"];\n      callback(null, oauth_token, oauth_token_secret, results);\n    }\n  });\n};\n\nexports.OAuth.prototype.signUrl = function (url, oauth_token, oauth_token_secret, method) {\n  if (method === undefined) {\n    var method = \"GET\";\n  }\n\n  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});\n\n  var parsedUrl = URL.parse(url, false);\n  var query = \"\";\n\n  for (var i = 0; i < orderedParameters.length; i++) {\n    query += orderedParameters[i][0] + \"=\" + this._encodeData(orderedParameters[i][1]) + \"&\";\n  }\n\n  query = query.substring(0, query.length - 1);\n  return parsedUrl.protocol + \"//\" + parsedUrl.host + parsedUrl.pathname + \"?\" + query;\n};\n\nexports.OAuth.prototype.authHeader = function (url, oauth_token, oauth_token_secret, method) {\n  if (method === undefined) {\n    var method = \"GET\";\n  }\n\n  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});\n\n  return this._buildAuthorizationHeaders(orderedParameters);\n};","map":null,"metadata":{},"sourceType":"script"}